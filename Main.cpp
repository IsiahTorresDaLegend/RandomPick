/*

Main.cpp
Program that randomly selects options from a list supplied by users.
Written by Isiah Torres
Course CSC 275 

*/
//================================================================================================

#include <chrono>	// included to use std::chrono::seconds()
#include <iostream>	// for input and output	
#include <random>	// to use random_device seed generator and mt19937 random number generator
#include <string>   // to use string objects
#include <thread>	// to perform multithreading
#include <vector>	// to create vectors
#include <stdexcept> // to add exceptions such as invalid_argument
#include <mutex>	// to use mutex objects to protect shared resources with threads.

using namespace std;

// mutex is short for mutual exclusion. It is used to protect shared resources from 
// simultaneous access. A mutex can be locked and unlocked. Once a mutex is locked, current thread
// owns mutex until it is not unlocked. It means no other thread can execute any instructions from
// the block of code surrounded by mutex until thread that owns mutex unlocks it.
mutex m; // create a global mutex object called m so all threads can access it. 


// Generate a random option in a separate thread
void generateItem(const vector<string>& items)
{
	// Seed the random number generator.
	
	// The random_device class is used to generate "non-deterministic" random numbers. It uses 
	// hardware resources of entropy, such as system clocks, device interrupts, or other sources
	// of external randomness. It is intended to be a source of high-quality, unpredictable random
	// numbers that are suitable for security-sensitive applications. When a random_device object
	// is created, it will try to initialize itself using the best available source of entropy on 
	// the system. IMPORTANT NOTE: While intended to be a source of non-deterministic randomness,
	// on some platforms, the source on entropy may be predictable or subject to manipulation by
	// an attacker and therefore, random_device should not be used as the sole source of
	// randomness for security-critical applications. 
	// create a instance of the random_device class (rd), will be used to obtain a seed value.
	random_device rd; 

	// The 'mt19937' class is used to generate pseudo-random numbers. It is a deterministic random
	// number generator meaning it generates a sequence of numbers that can be replicated exactly
	// if given the same initial seed value. mt19937 is based on the Mersenne Twister algorithm,
	// which is a highly regarded algorithm for generating high-quality pseudo-random numbers. 
	// The Mersenne Twister algorith is a type of linear feedback shift register (LFSR) generator
	// that uses a large state array (624 elements in the case of mt19937) to generate a sequence
	// of numbers that appear to be random. When creating an mt19937 object, we need to supply a 
	// seed value. That seed value is used to initialize the internal state of the generator. We
	// can use mt19937 to generate random numbers using various distribution functions such as
	// 'uniform_int_distribution' and 'normal_distribution'. The distribution functions take the
	// output of mt19937 and map it to a specific range or distribution of values.
	// IMPORTANT NOTE: Not suitable for security-critical applications, mt19937 is deterministic
	// and can be predicted if an attacker knows the seed value. Should not be used for 
	// cryptographic purposes. 
	// Create an instance of the mt19937 class (gen) and initialize it with a seed value from
	// random_device instance (rd). rd calls the operator() to return a seed value. 
	mt19937 gen(rd()); 

	// generate a random index into the list of items
	// uniform_int_distribution class is used to generate uniformly distributed pseudo-random
	// integers within a specified range. Must specify the range of integers we wish to generate.
	// We use random_number to generate a seed value for our mt19937 random number generator, and
	// we use a uniform_int_distribution object to generate random integers between 0 and the size
	// of the vector. The random integer is generated by calling the 'operator()' function of the 
	// 'dist' object with our 'gen' random number generator as an argument. The resulting value is
	// stored in the index variable. 'uniform_int_distribution' works by using the output of a 
	// random number generator, such as mt19937, to map a range of integers to the specified range.
	// The algorithm used to perform this mapping ensures that each integer in the specified range
	// has an equal probability of being generated. 
	uniform_int_distribution<> dist(0, items.size() - 1);
	int index = dist(gen);

	// simulate some work by sleeping for a second.
	// the this_thread namespace is used to interact with the current thread.
	this_thread::sleep_for(chrono::seconds(2));

	m.lock(); // lock mutex object to prevent other threads from accessing the cout resource.
	// Print the option/item's name
	cout << "\nChose option: " << items[index] << endl;	
	// use the this_thread namespace to call the get_id() function for the current thread
	// display to user when a thread is finished with the associated thread id.
	// cout << "Thead " << this_thread::get_id() << " finished working.\n"; For debugging
	m.unlock(); // unlock mutex when finished so other threads can access the cout resource.
}

int main()
{
	string repeat = "y"; // used to determine if program should loop again. 
	while (repeat == "y") // loop until user enters 'n' when asked to run again.
	{
		system("cls"); // Windows system command to clear console.

		cout << "\n\n";
		// use a raw string literal to add ascii art as a title for program. 
		cout << R"(    ____                  __                ____  _      __  
   / __ \____ _____  ____/ /___  ____ ___  / __ \(_)____/ /__
  / /_/ / __ `/ __ \/ __  / __ \/ __ `__ \/ /_/ / / ___/ //_/
 / _, _/ /_/ / / / / /_/ / /_/ / / / / / / ____/ / /__/ ,<   
/_/ |_|\__,_/_/ /_/\__,_/\____/_/ /_/ /_/_/   /_/\___/_/|_|)";

		// Print to user a brief description of program. 
		cout << "\n\nCan't decide what to do? Need to select a random winner? \n"
			<< "How about creating random teams? Want to pick 5 random game modes for a tournament?\n"
			<< "Maybe you just need help choosing an option. Let a computer do it for you!\n"
			<< "RandomPick is a program that will randomly choose from a list of options you give.\n";

		// prompt user to enter the options.
		vector<string> options; // create a vector to store options to choose from.
		vector<string>& rOptions = options; // create a reference to that vector. 
		bool success = false; // to know when the loop is done.
		do
		{
			cout << "\nEnter the options to choose from (one per line, empty line to finish):\n";
			string item; // will be used to store user input. 
			while (getline(cin, item) && !item.empty()) // get user input until user enters empty line.
			{
				// push_back() adds elements to the end of a vector. 
				rOptions.push_back(item); // add each item to the options vector. 
			}
			if (rOptions.size() < 2)
			{
				cout << "\nException: Must supply at least two options to choose from.\n";
				rOptions.clear();
				continue;
			}
			else success = true;
		} while (success == false);


		string tasks; // This is where the user's answer will be stored.
		int numTasks; // string tasks will be converted to an int. 
		success = false;
		do
		{
			// prompt user to enter how many results would they like.
			cout << "\nHow many results would you like to be returned?\n";
			try // try to execute this code normally...
			{
				getline(cin, tasks); // get user input and store the answer in tasks
				numTasks = stoi(tasks); // use stoi to convert the string to an int value.
				// if stoi throws an exception, the next lines will be skipped.
				if (numTasks > rOptions.size())
				{
					throw "\nInput out of range, please enter a number within the size of the list.\n";
				}
				success = true;
			}
			// if an error occurs, use the following exception handles.
			catch (const invalid_argument& e) // catch stoi() invalid_argument exception.
			{
				// inform the user of the problem.
				cout << "\nInvalid input. Please enter a valid number.\n";
				continue; // jump back to the beginning of the loop.
			}
			catch (const out_of_range& e) // catch stoi() out_of_range exception.
			{
				// inform user of the problem.
				cout << "\nInput out of range, please enter a smaller number.\n";
				continue; // jump back to the beginning of the loop .
			}
			catch (const char* e) // if the if condition throws the exception...
			{
				// inform user of the problem
				cout << e << endl;
				continue;
			}
		} while (success == false);

		// Used ANSI escape codes to change the color and style of the console output. 
		// '\033[1m' is bold and '\033[32m' is green. We can put them together by using the semicolon
		// Ex: '\033[1;32m', we then use '\033[0m' to reset all styles to default. 
		cout << "\n\033[1;32mWorking...\033[0m\n";

		// create a vector of threads
		vector<thread> threads;

		// create amount of threads == the amount of results requested.
		for (int i = 0; i < numTasks; i++)
		{
			// Here we use emplace_back() which constructs a new element in-place at the end of the 
			// vector, using the constructor of the element's class. emplace_back() constructs a new
			// thread object whose constructor takes a function and it's arguments.  
			// we pass the thread constructor the function to work with and a reference to a vector.
			threads.emplace_back(generateItem, rOptions);
		}

		// join the threads using a ranged based for loop. For each thread object or element within
		// the threads vector, call the join() method. This ensures that the main thread waits for 
		// all other threads to be finished before continuing with the program. 
		for (auto& thread : threads)
		{
			thread.join();
		}
		string choice;
		success = false; // reset success to false to use in do loop.
		do // do this action at least once until user selects a proper option.
		{
			try // try the following actions. 
			{

				cout << "Would you like to run again? (enter y or n)\n";
				getline(cin, choice);
				if (choice == "y" || choice == "n") // if choice == y or n, repeat the program.
				{
					repeat = choice; // while loop continues.
					success = true; // do loop ends.
				}
				else // if choice3 does not equal y or n
				{
					// throw this exception. this is a string, but strings are objects, not 
					// data types... 
					throw "Exception: Invalid answer, please enter 'y' for yes or 'n' for no.\n\n";
				}
			}
			// the exception is essentially an array of characters so to refer to it we must use
			// a pointer.
			catch (const char* e)
			{
				cout << e << endl; // display the exception message to user.
			}

		} while (success == false); // continue loop until successful. 

	}
	return 0;
}

// TODO: Allow user to pass a text file as a list?